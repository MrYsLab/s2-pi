{
    "docs": [
        {
            "location": "/",
            "text": "s2-pi\n\n\nCreating\nScratch 2\nExtensions\nOn Your Raspberry Pi\n\n\n\n\nIntroduction\n\n\nThe \nlatest Raspbian image\n (2018-10-09) as of this writing,\n includes an\noffline version of the Scratch 2 editor. It is based on Scratchx, a version of Scratch 2 that\nsupports Scratch 2 extensions. The previous \nJessie\n version of Raspbian is also compatible\nwith s2-pi.\n\n\nThis tutorial will show you how to create your own custom extensions.\n\n\nWhat is a Scratch Extension?\n\n\nA Scratch extension allows you to create, display and manage your own custom Scratch\nblocks. The extension blocks appear in the More Blocks section\nof the Scratch editor.\n\n\nThese blocks,\nsimilar to the standard set of Scratch blocks,\ncan optionally contain drop down list menus and/or provide a place for users to enter\nparameters. In addition, the extension contains the code that implements\n the block's \nactions\n.\n\n\n\n   \n\n\n\n\nThe extension file is written in JavaScript and must meet the criteria described in the \nScratchx\n extension documentation\n.\n\n\nWe will be using the \ns2-pi\n project to illustrate how an extension\nis created. The s2-pi project adds blocks to Scratch that allow you control GPIO pins on the Raspberry\nPi. The custom Scratch blocks created with s2-pi are shown above.\n\n\nIf you are not particularly interested in GPIO control, but would still like to build an extension\nto meet your own needs, this tutorial will help get you started. Although my interest is in GPIO\ncontrol, extensions need not be limited to GPIO control.\n\n\nUpon completing this tutorial you should be able to create an\nextension that can do almost anything you can imagine!\n\n\nLet's Get Started\n\n\nHere is what we are going to be doing:\n\n\n\n\nInstall the s2-pi demo code and its dependencies.\n\n\nUsing the s2-pi code, learn how to create and install custom blocks into Scratch.\n\n\nCreate a Python server that will interact with the custom blocks. The server is optional, but\nimplementing a server greatly increases the capability and flexibility of the extension.\n\n\n\n\nOK, before heading into the details, let's talk a little bit about what this demo extension\nactually does.\n\n\nThe s2-pi Demo\n\n\nThis demo creates 6 custom Scratch extension blocks.\nThe function of these blocks can be summarized as follows:\n\n\n\n\nA block that establishes communication between Scratch and a Python server.\n\n\nA block that allows you to set any GPIO pin to a high or low state.\n\n\nA block that allows you to control the output level of any GPIO pin using PWM.\n\n\nA block that allows you to control a servo motor and sets its angle.\n\n\nA block that will generate a tone on any GPIO pin that is connected to a piezo buzzer device.\n\n\nA block that allows you to set any GPIO pin as an output pin.\n\n\nA block that allows you get the current state of any pin that has been set as an output.\n\n\n\n\nPlease Note:\n This demo uses Python 3 (included with the Raspbian distribution). When coding\n your own server, you can choose to use Python 2 or 3, or if you prefer to code purely in\n JavaScript, you can code the server using node.js.\n\n\nInstalling s2-pi\n\n\nThe preferred installation method is to use the \npip tool\n. To install using \npip\n open a\nterminal window and type:\n\n\nsudo pip3 install s2-pi\n\n\n\n\n\nYou can also install s2-pi by downloading the code from Github.\n\n\nHere is how to use this alternative method:\n\n\nDownload the code from \nGithub\n\n\n\n\n\n\nClick on the download button on the Github page.\n    \n\n    \n\n\n\n\n\n\nUnzip the file. For the purposes of this discussion, the files were extracted into\n    the home directory \n/home/pi\n. The screen shot below shows the directory structure after\n    unzipping.\n\n\n\n\n\n\n\n\n\n\n\n\nGo to /home/pi/s2-pi-master and type:\n\n\n\n\n\n\nsudo python3 setup.py install\n\n\nThe installation will:\n\n\n\n\nCopy the extension file, s2_pi.js into your home directory, making it easy to find.\n\n\nPlace a startup executable, \ns2pi\n on the executable path that both starts the server\n and Scratch 2 in one command.\n\n\nPlace a file name conversion utility, \nsbx_to_sb2\n, on the executable path, to convert\nScratch .sbx files to Scratch .sb2 files.\n\n\n\n\nIMPORTANT NOTE\n: The \ns2-pi\n server uses the \npigpio\n library\n for GPIO pin control. This library is included with the Raspbian distribution, and \ns2pi\n\n will start the \npigpiod\n daemon process automatically.\n\n\nIf you wish to have the \npigpiod\n daemon start automatically at boot time, open a\nterminal window and then type:\n\n\nsudo systemctl enable pigpiod\nsudo systemctl start pigpiod\n\n\n\n\nYou need only do this procedure once - after executing these two commands, \npigpiod\n will\nautomatically be started each time you boot your Raspberry Pi.\n\n\nStarting The s2-pi Server\n\n\nNext, to start s2-pi, in a command terminal type:\n\n\ns2pi\n\n\nNotice this command contains 4 characters without a dash character.\n\n\nThis command starts both the server and opens up the Scratch editor.\n\n\n\n\n\n\n\nYou may see some warnings in the console window generated by Scratch. These can safely be\nignored.\n\n\nInstalling The s2-pi JavaScript Extension File Into The Scratch Editor\n\n\nThere are 2 possible methods for installing an extension into Scratch.\nThe first method is the\nsimpler method. It is most useful when developing a new extension or trying out an\nextension for the first time.\n\n\nOnce you have finalized your extension design, you may wish to install your extension\ninto the \nScratch\nExtension Library\n, making it easier for your users to access and use your extension.\nThe \nMethod 2\n discussion will explain how this is accomplished.\n\n\n\n\n\n\n\nSelect the method that best suits your needs.\n\n\nExtension Installation Method 1- Using File Menu\n\n\nTo install using this method, while holding the Shift key on your keyboard,\nclick on the File menu choice at the top of the Scratch 2 window.\nSelect \nImport Experimental Extension\n and you will be\nprompted for a URL to load the file:\n\n\n\n   \n\n\nYou need to supply the full path and file name of the JavaScript extension for the URL. Unfortunately,\n Scratch does not allow cut and paste into this dialog box, so it needs to be entered manually. In\n addition, wildcards are not allowed, so the entire path and file name must be entered.\n\n\nThe path and file we will be using is:\n\n\n/home/pi/s2_pi.js\n\n\nIf you click on the \nMore Blocks\n tab, you should now see the extension blocks appear.\n\n\n\n\n\n\n\nIf you do not see the blocks appear, check the path and file. If Scratch cannot find the file,\nit remains silent. \nNot very friendly\n.\n\n\nWhen developing your own JavaScript extension file, if there are any syntax errors within the\nfile, the blocks will not appear, and once again, Scratch is silent. \nEven less friendly\n.\n\n\nExtension Installation Method 2  - Adding An Extension to the Extension Library\n\n\nYou can also have your extension appear for selection in the \nMore Blocks\n section by pressing\nthe \nAdd an extension\n button.\n\n\n\n\n\n\n\n\n\n\n\n\nTo add an extension to the \nExtension Library\n we will need to perform the following steps:\n\n\n\n\nDownload a copy of the JavaScript extension file to /usr/lib/scratch2/scratch_extensions.\n\n\nDownload a modified copy of /usr/lib/scratch2/scratch_extensions/extensions.json\n so that our extension is added.\n\n\nDownload an icon for our extension into /usr/lib/scratch2/medialibrarythumbnails.\n\n\n\n\nWe will download these files for the sake of this tutorial. When creating your own\nextension, you would copy the files directly from your workspace.\n\n\nDownloading the JavaScript Extension File\n\n\nOpen a terminal window and type:\n\n\ncd /usr/lib/scratch2/scratch_extensions\n\n\n\n\nThen execute the following line in the terminal window:\n\n\nsudo curl -o s2_pi.js  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/s2_pi/s2_pi.js\n\n\n\n\nDownload a Modified Version Of extensions.json\n\n\nTo have the extension appear in the Extension Library Page, we need to add a line to\n/usr/lib/scratch2/scratch_extensions/extensions.json describing our extension.\n\n\nThe line has already been added to the file we will download, but first, let's take a look\nat the format of the entry.\n\n\n{ \"name\":\"Custom Pi GPIO\", \"type\":\"extension\", \"file\":\"s2_pi.js\", \"md5\":\"mry.png\", \"url\":\"https://mryslab.github.io/s2-pi/\", \"tags\":[\"hardware\"]  },\n\n\n\n\nThe json entry contains the following fields:\n\n\n\n\nname - The title that will appear in the Extension Library pagefor our extension.\n\n\ntype - This needs to be set to \"extension\".\n\n\nfile - This is the name of our JavaScript extension file.\n\n\nmd5  - This is the name of the icon file we wish to have appear in the Extension library\n page.\n\n\nurl  - This is the URL for documentation for the extension.\n\n\ntags - The category that our extension is part of. This needs to be set to \"hardware\"\n\n\n\n\nWe can download a file that already has the additional line added.\n\n\nMake sure that the terminal window is still in /usr/lib/scratch2/scratch_extensions,\nthen type:\n\n\nsudo curl -o extensions.json  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/additional_files/extensions.json\n\n\n\n\n\nDownload An Icon File\n\n\nTo download the MrYsLab logo, first type the following in the terminal window:\n\n\ncd /usr/lib/scratch2/medialibrarythumbnails\n\n\n\n\nNext type:\n\n\nsudo curl -o mry.png  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/docs/images/mry.png\n\n\n\n\n\nInstalling The Extension From The Extension Library\n\n\nAfter starting s2pi, when the Scratch editor appears, go to the More Blocks section of the\neditor.\n\n\n\n\n\n\n\nClick on the Add an Extension button and the Extension Library page will appear.\n\n\n\n\n\n\n\nDouble click the MisterYsLab icon, and the extension blocks should appear.\n\n\n\n\n\n\n\nRemoving A Scratch Extension\n\n\nWhen developing an extension, you will probably need to reload it multiple times as you add features\nand get the bugs out. To remove an extension, click on the arrow next to the extension name and select\n\nRemove extension blocks\n.\n\n\nYou are now ready to make your changes and to reload the extension.\n\n\n\n\n\n\n\nUsing The s2-pi Blocks\n\n\nNow that the JavaScript extension has been loaded and the server is running, you can try using\nthe extension blocks within the Scratch editor.\n\n\nAs each custom Scratch block is executed, the terminal window will display the message sent from\nthe extension to the server. If a pin is set to be a digital input, and the pin\nchanges state, the changes for that pin\nwill also be displayed in the console with the pigpio callback information.\n\n\n\n\n\n\n\nThe NOT SANDBOXED message is coming from Scratch because we started Scratch from\ninside a terminal window. This message can be safely ignored.\n\n\nOpening A Communication Channel Between The Extension And The Server\n\n\nScratch does not provide a mechanism to\nautomatically connect a communication channel between the extension and the server.\nTherefore, the \nConnect to s2-pi server block\n\nmust be executed before using any of the other blocks.\n\n\nIf you forget to do this, an alert will appear on the screen. In addition, the connection indicator\nwill be yellow.\n\n\n\n\n\n\n\nWhen the connection is complete the indicator will go from yellow to green.\n\n\n\n\n\n\n\n\n\n\n\n\nChanging The State Of A Digital Output Pin\n\n\nIf you have a device, such as an LED connected to a GPIO pin, you can set its state to a \"1\" or \"0\"\nby using the \nSet BCM Output block\n.\n\n\nChanging The State Of A Digital Output Pin Using PWM\n\n\nUsing the same LED device, you can set its brightness (from 0 to 255) using the \nSet BCM PWM Output\n block.\n\n\nGetting Input From A Digital Input Pin\n\n\nIf you have a device, such as a switch, connected to a GPIO pin, you can read the switch's current\nstate. First, you must set the pin as an input using the \nSet BCM as Input\n block. This sets up pigpio\nto provide notification of a state change on the pin. Now to see the current state, use the Read Digital\nPin reporter block.\n\n\nControlling A Servo Motor\n\n\nIf you connect a servo motor to a GPIO pin, you can control its movement between 0 and 180 degrees by using the\n\nSet BCM As Servo\n block.\n\n\nPlaying A Tone\n\n\nIf you connect a Piezo buzzer to a GPIO pin, you can play a short tone by using the \nTone\n block.\n\n\nCreating a JavaScript Extension File\n\n\nThe format for the JavaScript extension file has been defined by the Scratch team and\nyou can view the specification \non this web page\n.\n\n\nThe JavaScript extension file is comprised of boiler plate code,\nblock descriptor code that creates the Scratch blocks in the Scratch editor,\nand the code that you write that acts as a callback for the blocks created in the descriptor section.\n\n\nThis was mentioned previously, but we will take this opportunity to mention it again. As you write\nyour JavaScript extension code\nand install it into the Scratch editor, the installation may result in no blocks being displayed.\nIf you introduce any errors in the file, Scratch silently fails, leaving you to debug your\nfile without any help from Scratch. Therefore it is a good idea to work on things incrementally.\n\n\nBasic Boiler Plate\n\n\nI would suggest, first starting with the basic boiler plate provided in the specification.\n\n\n(function(ext) {\n    // Cleanup function when the extension is unloaded\n    ext._shutdown = function() {};\n\n    // Status reporting code\n    // Use this to report missing hardware, plugin or unsupported browser\n    ext._getStatus = function() {\n        return {status: 2, msg: 'Ready'};\n    };\n\n    // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n        ]\n    };\n\n    // Register the extension\n    ScratchExtensions.register('Sample extension', descriptor, ext);\n})({});\n\n\n\n\n\nJust copy this code into your favorite editor, and save the file with a .js extension.\nThen load the file into Scratch. You should then see something like this in the Scratch Editor.\nRemember to select More Blocks or you will not see the custom blocks. In this case, we have\nnot yet defined any blocks, and that is why no blocks appear.\n\n\n\n\n\n\n\nNow let's modify the boiler plate slightly to change the indicator from the default green to yellow.\nAlso, we will change the title of the extension from \"Sample Extension\" to \"My Extension\".\n\n\n(function(ext) {\n    // Cleanup function when the extension is unloaded\n    ext._shutdown = function() {};\n\n    // Status reporting code\n    // Use this to report missing hardware, plugin or unsupported browser\n    ext._getStatus = function() {\n        return {status: 1, msg: 'Ready'};\n    };\n\n    // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n        ]\n    };\n\n    // Register the extension\n    ScratchExtensions.register('My extension', descriptor, ext);\n})({});\n\n\n\n\n\nTo change the color of the indicator,  \nstatus\n was set from a value of 2 to 1,\nand to change the extension name, the line near the bottom of the file was modified.\n\n\n\n\n\n\n\nBlock Descriptor Section\n\n\nThe specifications for creating different types of blocks, including adding drop down menus\nand parameter fields within the blocks is nicely documented on\nthe \nScratch page\n,\nso we won't cover that information in detail here. Let's just take a quick look at the\nblocks descriptors that s2-pi uses.\n\n\n    // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n            // Block type, block name, function name\n            [\"w\", 'Connect to s2_pi server.', 'cnct'],\n            [\" \", 'Set BCM %n as an Input', 'input','PIN'],\n            [\" \", \"Set BCM %n Output to %m.high_low\", \"digital_write\", \"PIN\", \"0\"],\n            [\" \", \"Set BCM PWM Out %n to %n\", \"analog_write\", \"PIN\", \"VAL\"],\n            [\" \", \"Set BCM %n as Servo with angle = %n (0\u00b0 - 180\u00b0)\", \"servo\", \"PIN\", \"0\"],     // ***Hackeduca --> Block for Servo\n            [\" \", \"Tone: BCM %n HZ: %n\", \"play_tone\", \"PIN\", 1000],\n            [\"r\", \"Read Digital Pin %n\", \"digital_read\", \"PIN\"]\n\n        ],\n        \"menus\": {\n            \"high_low\": [\"0\", \"1\"]\n\n        },\n        url: 'http://MrYsLab.github.io/s2-pi'\n    };\n\n\n\n\n\nA block descriptor consists of several fields.\n\n\n\n\nThe first field describes the shape of the block.\nCommand blocks are created by setting the first fields to \" \".  A reporter block is created by setting\nthis field to \"r\".\n\n\nThe second field is the text that\nappears in the block. Within that text, you might include a drop down menu, shown by using %m. The\nmenu contents are defined within the \nmenu\n section of the block descriptor.\nYou can also have the block provide blanks for the\nuser to input parameters for the block. %n indicates that this parameter will be a number.\n\n\nThe third field is the name of the function that will be called when the block executes.\nYou will need to provide the contents of that function within the extension file.\n\n\nThe remaining fields provide default values for the parameters defined, if any, in the second\ndescriptor field.\n\n\n\n\nBlock Handlers\n\n\nOnce you have your blocks created and are able to successfully load them into Scratch,\nit is time to create the code for the block handlers.\n\n\nA Really Simple Example\n\n\nNow let's create a really simple extension file that will do all of the processing within\nthe JavaScript file (no server is needed). When this extension is loaded, the indicator is set\nto yellow. When the \nStart The Program\n block is executed, it will turn the indicator from\nyellow to green.\n\n\n(function(ext) {\n\n   var myStatus = 1 ; // initially set status to yellow\n   // Cleanup function when the extension is unloaded\n\n   ext._shutdown = function() {};\n\n   // Status reporting code\n\n   // Use this to report missing hardware, plugin\n\n   // or unsupported browser\n\n   ext._getStatus = function() {\n     return {status: myStatus, msg: 'Ready'};\n   };\n\n   // added function to support the Start The Program block\n   ext.goGreen = function() {\n     myStatus = 2;\n   };\n\n   // Block and block menu descriptions\n   var descriptor = {\n     blocks: [\n       [\" \", \"Start The Program\", \"goGreen\"]\n     ]\n   };\n\n   // Register the extension\n   ScratchExtensions.register('My extension', descriptor, ext);\n })({});\n\n\n\n\n\nIn this extension, We add a variable, \nmyStatus\n and initialize it with a value of\n\"1\".\n\n\nThe _getStatus method, a method that Scratch calls periodically to set the indicator, has\nbeen modified. We changed the hard coded value for status to be the myStatus variable. Because\nmyStatus is set to \"1\" the indicator is initially yellow.\n\n\nWe defined a \nStart The Program\n block and in the descriptor indicated that this block will\nbe handled by the \ngoGreen\n function.\n\n\nThe goGreen function, called when the block is used in a Scratch script, sets myStatus to \"2\", which\n will turn the indicator to green.\n\n\nAs you can see, it is possible to perform all of the processing in the JavaScript extension. In fact,\nthe default extension provided with Scratch for the Raspberry Pi, \"Pi GPIO\", does just that. It\ncontrols the GPIO pins by making some low-level GPIO calls.\n\n\nHowever, if you wish to start connecting more complicated devices, such as i2c devices,\nprogramming may get to be difficult, if not impossible, because of the limitations imposed by\nScratch on the extension file.\n\n\nFor example, getting the \"Pi GPIO\" extension to play a tone would be, to say the least, a challenge.\n\n\nTo get around the restrictions imposed by the Scratch editor, we can add a server\nfor flexibility and ease of programming.\n\n\nProviding A Communication Channel Between Scratch And The Server\n\n\nAs mentioned before, you can do all processing within the extension if you wish,\nbut personally, I prefer to\n\"outsource the rough stuff\" to another process. For s2-pi, that process is s2_pi.py.\n\n\nThe one complication is that we need a way for the Extension and server process to be able to\ncommunicate with one another, asynchronously and bi-directionally. Whenever a command extension\nblock is executed, it needs to be able to send the command, in addition to any parameters that may\nbe associated with that command, to the server process.\n\n\nAnd in the other direction, from the server to the extension, the server needs to be able to notify\nthe extension whenever a reporting event occurs.\n\n\nThe communication should be asynchronous in that neither the extension nor the server should need\nto poll for incoming messages. This makes the system a lot more efficient and easier to program.\nNot having\nthe need for complicated concurrency schemes is a plus. When a message arrives, it essentially\ngenerates an event that triggers the processing of that message. When no messages are available,\nthe program is essentially dormant.\n\n\nSome WebSocket Background\n\n\nWebSockets satisfy all of our communication needs rather nicely, and since it is already\nbuilt into Scratch, extension implementation is greatly\nsimplified. Unfortunately, none of this is documented by the Scratch team. Don't worry,\n we will show you how to use WebSockets in the extension. For the server, we just need to create a\n class that implements the server inherited from\na WebSocket library base class. Again, you will be shown how to manage WebSockets on the server side as well.\nAll in all, it is a pretty elegant and simple solution for our communication needs.\n\n\nA WebSocket is \ndefined by Wikipedia\n as a\n\"a computer communications protocol, providing full-duplex communication channels\nover a single TCP connection\". WebSockets by their nature are event driven, and therefore are a perfect\nfit for our needs.\n\n\nSimilar to an IP socket, one side of the connection acts as the client that initiates the socket,\nand the other\nside is the server that accepts connection requests and completes the connection.\n\n\nFor s2-pi the extension is the client, and the server is, you guessed it, the server.\n\n\nThe WebSocket API requires some methods to be implemented to support the WebSocket event\ndriven protocol.\n\n\nLet's take a look at how s2-pi establishes a WebSocket, and the code it uses to do so.\n\n\nEstablishing The Connection\n\n\nIn order to establish a connection, we first need a WebSocket server to be running and ready\nto accept connection requests. The s2_pi.py server, S2PI,  inherits from the WebSocket class.\nS2PI needs to overwrite and implement 3 methods inherited from the base class:\n\n\n\n\nhandleConnected\n\n\nhandleMessage\n\n\nhandleClose\n\n\n\n\nSimilarly, on the client, JavaScript extension side, we need to implement a similar set of functions.\n\n\n\n\nwindow.socket.onopen\n\n\nwindow.socket.onmessage\n\n\nwindow.socket.onclose\n\n\n\n\nIn \ns2_pi.py\n,\nthe function near the bottom of the file, \nrun_server\n, in addition to starting\nup Scratch, instantiates the WebSocket providing the IP address and port\nnumber we wish to use. We also need to pass a reference to our implementation\nclass (S2PI) so that the overwritten methods within S2PI will be called\nwhen a WebSocket event occurs.\nThe last line of the method assures that the WebSocket server will run \"forever\".\n\n\ndef run_server():\n    os.system('scratch2&')\n    server = SimpleWebSocketServer('', 9000, S2Pi)\n    server.serveforever()\n\n\n\n\n\nThe run_server method is called when we start s2_pi.py:\n\n\nif __name__ == \"__main__\":\n    try:\n        run_server()\n    except KeyboardInterrupt:\n        sys.exit(0)\n\n\n\n\n\n\nOnce \nrun_server\n is called, S2PI is waiting for a connection request.\n\n\nNow it's the extension's turn to initiate the connection request.\nIn order for the server to receive a connection request, the\n\nConnect to s2_pi server\n block must be executed within a Scratch script.\nActivating this block calls the \ncnct\n function within our JavaScript extension.\n`\nThe \ncnct\n function instantiates a WebSocket using the same IP address and port number used by the server.\nThe instantiation issues a connection request.\n\n\next.cnct = function () {\n        window.socket = new WebSocket(\"ws://127.0.0.1:9000\");\n\n\n\n\n\nWhen the server receives this connection request, a handshake between both sides ensues, and\nif the connection is successful, \nhandleConnected\n is called.\n\n\nOn the extension end, a successful connection results in \nwindow.socket.onopen\n being\ncalled.\n\n\nBoth sides are now ready to send and receive messages.\n\n\nFormatting Messages To Go Across The Network\n\n\nBy convention, our application will use a hash/dictionary data structure to construct\nour messages. A hash (JavaScript) and dictionary(Python) are roughly equivalent data structures,\nthat allow the easy extraction of data using name/value pairs.\n\n\nLuckily, the syntax for both JavaScript and Python are the same.\n\n\nHere is a list of messages constructed and sent by the Scratch extension to notify the\nserver that a command block has been executed:\n\n\nBlock:                    Connect To s2-pi Server\nMessage:                  {'command': 'ready''}\n\nBlock:                    Set BCM Pin As An Input\nMessage:                  {'command': 'input', 'pin': pin}\n\nBlock:                    Set BCM Output To\nMessage:                  {'command': 'digital_write', 'pin': pin, 'state': state}\n\nBlock:                    Set BCM PWM Output\nMessage:                  {'command': 'analog_write', 'pin': pin, 'value': value}\n\nBlock:                    Set BCM as Servo\nMessage:                  {'command': 'servo', 'pin': pin, 'value': value}\n\nBlock:                    Tone\nMessage:                  {'command': 'tone', 'pin': pin, 'frequency': frequency}\n\n\n\n\n\nNotice that each of these messages has a \ncommand\n field to identify the type of message.\nWhen the server receives a message, it simply dereferences the command field to determine the action\nto take.\n\n\nOn both sides of the interface, we convert the hash/dictionary message structures into strings\nusing JSON, so that message can be carried over the network. When a message is received,\nwe need to reconstruct the string back to the native data structure so that we can easily access\nall the fields of the message.\n\n\nTo convert from a hash to a string on the extension side, the JSON.stringify method is used.\n\n\nvar msg = JSON.stringify({\n                \"command\": \"ready\"\n            });\n            window.socket.send(msg);\n\n\n\n\nThe converted message is then sent over the socket using the \nsend\n function.\n\n\nWhen the message is received on the server side, it needs to be converted from the string representation\nback to the native data structure.\n\n\nThe \nhandleMessage\n method in s2_pi.py performs this conversion.\n\n\npayload = json.loads(self.data)\n\n\nHere the string, represented as self.data, is converted back to the data structure by the call to\njson.loads. The converted string is assigned to the payload variable and can now be manipulated as\na standard Python dictionary.\n\n\nYou've probably noticed that all the WebSocket action of interest is handled by\n\nwindow.socket.onmessage\n on the JavaScript side, receiving any messages that the server sends,\nsuch as reporter data, and \nhandleMessage\n on the Python side, receiving all the command\nrequests from the extension.\n\n\nReporter Blocks\n\n\nFor S2PI, the only reporter block is \nRead Digital Pin\n. Before using this block in a Scratch\nscript,\nthe \nSet BCM as an Input\n block must first be used.\n\n\nThe following is the implementation function in the extension for this block:\n\n\next.input = function (pin) {\n        if (connected == false) {\n            alert(\"Server Not Connected\");\n        }\n        // validate the pin number for the mode\n        if (validatePin(pin)) {\n            var msg = JSON.stringify({\n                \"command\": 'input', 'pin': pin\n            });\n            window.socket.send(msg);\n        }\n    };\n\n\n\n\n\nWe first make sure that a connection was established, and if not an alert is generated in the\nScratch editor. Next, we make sure that the pin specified is valid. The check to do this simply checks\nthe pin is in the range of 0-31. Finally, we create and send a message with a command of \"input\"\nsupplying\nthe pin number that the user entered in the block.\n\n\nWhen the server receives this message, the selected GPIO pin is set to be an input pin.\n\n\n    def handleMessage(self):\n        # get command from Scratch2\n        payload = json.loads(self.data)\n        print(payload)\n        client_cmd = payload['command']\n        # When the user wishes to set a pin as a digital Input\n        if client_cmd == 'input':\n            pin = int(payload['pin'])\n            self.pi.set_glitch_filter(pin, 20000)\n            self.pi.set_mode(pin, pigpio.INPUT)\n            self.pi.callback(pin, pigpio.EITHER_EDGE, self.input_callback)\n\n\n\n\n\nHere is the beginning of the server's \nhandleMessage\n method. The first thing that happens is\nwhen a message is received, is that the message is converted back to a dictionary.\n\n\nThe message just received was an \ninput\n command message. The pin number is extracted from the\nmessage, converted from its string representation to an integer, and then 3 pigpio calls are made.\n\n\nThe first sets a \"glitch\" value. If using a push button switch, this will\n\ndebounce\n\n the switch.\n\n\nThen the pin is set to be an input pin, and finally, we associate a callback method for pigpio to\ncall whenever there is a state change detected on the pin.\n\n\nWhen a call back occurs, a message is constructed and sent to the extension notifying it of the\nstate change.\n\n\n    def input_callback(self, pin, level, tick):\n        payload = {'report': 'digital_input_change', 'pin': str(pin), 'level': str(level)}\n        print('callback', payload)\n        msg = json.dumps(payload)\n        self.sendMessage(msg)\n\n\n\n\n\nThe \njson,dumps\n call translates the dictionary into a string.\n\n\nThe message is then sent with the sendMessage call.\n\n\nThe extension receives this message in its \nonmessage\n function.\n\n\nwindow.socket.onmessage = function (message) {\n            var msg = JSON.parse(message.data);\n\n            // handle the only reporter message from the server\n            // for changes in digital input state\n            var reporter = msg['report'];\n            if(reporter === 'digital_input_change') {\n                pin = msg['pin'];\n                digital_inputs[parseInt(pin)] = msg['level']\n            }\n            console.log(message.data)\n        };\n\n\n\n\nHere the message is converted back to a hash by the call to JSON.parse. The report type is checked\nand the digital_inputs array is modified to reflect the state change.\nThe pin value is converted from its string representation to an integer and is used as an index to\nstore the state change information in the \ndigital_inputs\n array.\n\n\nWhen the \nRead Digital Input\n reporter block is encountered in a Scratch script,\nits associated function is called. The current state of the pin associated with this block\nis retrieved\nby indexing into the \ndigital_inputs\n array.\n\n\n[\"r\", \"Read Digital Pin %n\", \"digital_read\", \"PIN\"]\n\next.digital_read = function (pin) {\n        if (connected == false) {\n            alert(\"Server Not Connected\");\n        }\n        else {\n                return digital_inputs[parseInt(pin)]\n\n        }\n    };\n\n\n\n\nSaving Your Project\n\n\nAfter creating your project you can save it by selecting \nFile/Save Project\n in the Scratch\neditor menu.\n\n\n\n\n\n\n\nThis will save your file with a .sbx extension.\n\n\nThe current version of the Scratch 2 editor contains a bug. If you go to save a project\nwhen using a custom extension (for some reason this bug does not occur if you use one of\nthe two \"standard\" extensions supplied with the editor), the file is saved with a .sbx\nextension. When you go to load a previously saved project, .sbx files do not appear in the\nproject choice menu. To get around this, .sbx projects need to be renamed using a .sb2\nextension.\n\n\nThe s2-pi distribution supplies a utility that will rename all .sbx files to .sb2 files for\na given directory.\n\n\nTo use this utility, open a terminal window and CD into the directory that contains\nthe .sbx project files.\n\n\nNext type the following to properly rename the files:\n\n\nsbx_to_sb2\n\n\n\n\nIf you modify a project that was loaded with the .sb2 extension and then save it, the file\nwill be renamed with the .sbx extension.\n\n\nHopefully, this rather annoying bug will be fixed in the near future.\n\n\nReloading A Saved Project\n\n\nWhen you select File/ Load Project, only .sb2 files are shown in the file chooser dialog.\nTherefore if you saved a project and did not convert its file type, refer to the previous\nsection \nSaving Your Project\n, to learn how to convert the file to the correct type.\n\n\nAfter fixing the file extension type, if you then select \nFile/Load Project\n, the .sb2 files be available\n for selection in the file chooser dialog.\n\n\nRed Blocks\n\n\nIf you installed the extension \nusing method 1\n, then\nwhen you load a previously saved project, you will see the extension blocks come up as\n\nred blocks\n:\n\n\n\n\n\n\n\nTo solve this problem, just reload the extensions blocks as described\nin the \nInstalling The s2-pi JavaScript Extension File Into The Scratch Editor\n section of\nthis document.\n\n\nAfter doing so, the extension blocks should be restored.\n\n\nGo Forth And Code!\n\n\nWe have explored:\n\n\n\n\nCreating a JavaScript Extension File\n\n\nCreating a Python server derived from the WebSocket class\n\n\nConstructing and sending messages, both in the extension and the server.\n\n\nReceiving, deconstructing and processing the message for both the extension and server.\n\n\n\n\nWith that in hand, you should have a good idea of how to code both the JavaScript extension and\nthe associated server side code.\n\n\nIf you have any comments, questions or suggestions, please let me know at:\n\n\nMisterYsLab@gmail.com\n\n\nContributors\n\n\nThe servo control code was developed and supplied by \nEdson Sidnei Sobreira",
            "title": "Create Your Own Scratch2 Extensions"
        },
        {
            "location": "/#introduction",
            "text": "The  latest Raspbian image  (2018-10-09) as of this writing,\n includes an\noffline version of the Scratch 2 editor. It is based on Scratchx, a version of Scratch 2 that\nsupports Scratch 2 extensions. The previous  Jessie  version of Raspbian is also compatible\nwith s2-pi.  This tutorial will show you how to create your own custom extensions.",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-a-scratch-extension",
            "text": "A Scratch extension allows you to create, display and manage your own custom Scratch\nblocks. The extension blocks appear in the More Blocks section\nof the Scratch editor.  These blocks,\nsimilar to the standard set of Scratch blocks,\ncan optionally contain drop down list menus and/or provide a place for users to enter\nparameters. In addition, the extension contains the code that implements\n the block's  actions .  \n      The extension file is written in JavaScript and must meet the criteria described in the  Scratchx\n extension documentation .  We will be using the  s2-pi  project to illustrate how an extension\nis created. The s2-pi project adds blocks to Scratch that allow you control GPIO pins on the Raspberry\nPi. The custom Scratch blocks created with s2-pi are shown above.  If you are not particularly interested in GPIO control, but would still like to build an extension\nto meet your own needs, this tutorial will help get you started. Although my interest is in GPIO\ncontrol, extensions need not be limited to GPIO control.  Upon completing this tutorial you should be able to create an\nextension that can do almost anything you can imagine!",
            "title": "What is a Scratch Extension?"
        },
        {
            "location": "/#lets-get-started",
            "text": "Here is what we are going to be doing:   Install the s2-pi demo code and its dependencies.  Using the s2-pi code, learn how to create and install custom blocks into Scratch.  Create a Python server that will interact with the custom blocks. The server is optional, but\nimplementing a server greatly increases the capability and flexibility of the extension.   OK, before heading into the details, let's talk a little bit about what this demo extension\nactually does.",
            "title": "Let's Get Started"
        },
        {
            "location": "/#the-s2-pi-demo",
            "text": "This demo creates 6 custom Scratch extension blocks.\nThe function of these blocks can be summarized as follows:   A block that establishes communication between Scratch and a Python server.  A block that allows you to set any GPIO pin to a high or low state.  A block that allows you to control the output level of any GPIO pin using PWM.  A block that allows you to control a servo motor and sets its angle.  A block that will generate a tone on any GPIO pin that is connected to a piezo buzzer device.  A block that allows you to set any GPIO pin as an output pin.  A block that allows you get the current state of any pin that has been set as an output.   Please Note:  This demo uses Python 3 (included with the Raspbian distribution). When coding\n your own server, you can choose to use Python 2 or 3, or if you prefer to code purely in\n JavaScript, you can code the server using node.js.",
            "title": "The s2-pi Demo"
        },
        {
            "location": "/#installing-s2-pi",
            "text": "The preferred installation method is to use the  pip tool . To install using  pip  open a\nterminal window and type:  sudo pip3 install s2-pi  You can also install s2-pi by downloading the code from Github.  Here is how to use this alternative method:  Download the code from  Github    Click on the download button on the Github page.\n     \n        Unzip the file. For the purposes of this discussion, the files were extracted into\n    the home directory  /home/pi . The screen shot below shows the directory structure after\n    unzipping.       Go to /home/pi/s2-pi-master and type:    sudo python3 setup.py install  The installation will:   Copy the extension file, s2_pi.js into your home directory, making it easy to find.  Place a startup executable,  s2pi  on the executable path that both starts the server\n and Scratch 2 in one command.  Place a file name conversion utility,  sbx_to_sb2 , on the executable path, to convert\nScratch .sbx files to Scratch .sb2 files.   IMPORTANT NOTE : The  s2-pi  server uses the  pigpio  library\n for GPIO pin control. This library is included with the Raspbian distribution, and  s2pi \n will start the  pigpiod  daemon process automatically.  If you wish to have the  pigpiod  daemon start automatically at boot time, open a\nterminal window and then type:  sudo systemctl enable pigpiod\nsudo systemctl start pigpiod  You need only do this procedure once - after executing these two commands,  pigpiod  will\nautomatically be started each time you boot your Raspberry Pi.",
            "title": "Installing s2-pi"
        },
        {
            "location": "/#starting-the-s2-pi-server",
            "text": "Next, to start s2-pi, in a command terminal type:  s2pi  Notice this command contains 4 characters without a dash character.  This command starts both the server and opens up the Scratch editor.    You may see some warnings in the console window generated by Scratch. These can safely be\nignored.",
            "title": "Starting The s2-pi Server"
        },
        {
            "location": "/#installing-the-s2-pi-javascript-extension-file-into-the-scratch-editor",
            "text": "There are 2 possible methods for installing an extension into Scratch.\nThe first method is the\nsimpler method. It is most useful when developing a new extension or trying out an\nextension for the first time.  Once you have finalized your extension design, you may wish to install your extension\ninto the  Scratch\nExtension Library , making it easier for your users to access and use your extension.\nThe  Method 2  discussion will explain how this is accomplished.    Select the method that best suits your needs.",
            "title": "Installing The s2-pi JavaScript Extension File Into The Scratch Editor"
        },
        {
            "location": "/#extension-installation-method-1-using-file-menu",
            "text": "To install using this method, while holding the Shift key on your keyboard,\nclick on the File menu choice at the top of the Scratch 2 window.\nSelect  Import Experimental Extension  and you will be\nprompted for a URL to load the file:  \n     You need to supply the full path and file name of the JavaScript extension for the URL. Unfortunately,\n Scratch does not allow cut and paste into this dialog box, so it needs to be entered manually. In\n addition, wildcards are not allowed, so the entire path and file name must be entered.  The path and file we will be using is:  /home/pi/s2_pi.js  If you click on the  More Blocks  tab, you should now see the extension blocks appear.    If you do not see the blocks appear, check the path and file. If Scratch cannot find the file,\nit remains silent.  Not very friendly .  When developing your own JavaScript extension file, if there are any syntax errors within the\nfile, the blocks will not appear, and once again, Scratch is silent.  Even less friendly .",
            "title": "Extension Installation Method 1- Using File Menu"
        },
        {
            "location": "/#extension-installation-method-2-adding-an-extension-to-the-extension-library",
            "text": "You can also have your extension appear for selection in the  More Blocks  section by pressing\nthe  Add an extension  button.      To add an extension to the  Extension Library  we will need to perform the following steps:   Download a copy of the JavaScript extension file to /usr/lib/scratch2/scratch_extensions.  Download a modified copy of /usr/lib/scratch2/scratch_extensions/extensions.json\n so that our extension is added.  Download an icon for our extension into /usr/lib/scratch2/medialibrarythumbnails.   We will download these files for the sake of this tutorial. When creating your own\nextension, you would copy the files directly from your workspace.",
            "title": "Extension Installation Method 2  - Adding An Extension to the Extension Library"
        },
        {
            "location": "/#downloading-the-javascript-extension-file",
            "text": "Open a terminal window and type:  cd /usr/lib/scratch2/scratch_extensions  Then execute the following line in the terminal window:  sudo curl -o s2_pi.js  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/s2_pi/s2_pi.js",
            "title": "Downloading the JavaScript Extension File"
        },
        {
            "location": "/#download-a-modified-version-of-extensionsjson",
            "text": "To have the extension appear in the Extension Library Page, we need to add a line to\n/usr/lib/scratch2/scratch_extensions/extensions.json describing our extension.  The line has already been added to the file we will download, but first, let's take a look\nat the format of the entry.  { \"name\":\"Custom Pi GPIO\", \"type\":\"extension\", \"file\":\"s2_pi.js\", \"md5\":\"mry.png\", \"url\":\"https://mryslab.github.io/s2-pi/\", \"tags\":[\"hardware\"]  },  The json entry contains the following fields:   name - The title that will appear in the Extension Library pagefor our extension.  type - This needs to be set to \"extension\".  file - This is the name of our JavaScript extension file.  md5  - This is the name of the icon file we wish to have appear in the Extension library\n page.  url  - This is the URL for documentation for the extension.  tags - The category that our extension is part of. This needs to be set to \"hardware\"   We can download a file that already has the additional line added.  Make sure that the terminal window is still in /usr/lib/scratch2/scratch_extensions,\nthen type:  sudo curl -o extensions.json  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/additional_files/extensions.json",
            "title": "Download a Modified Version Of extensions.json"
        },
        {
            "location": "/#download-an-icon-file",
            "text": "To download the MrYsLab logo, first type the following in the terminal window:  cd /usr/lib/scratch2/medialibrarythumbnails  Next type:  sudo curl -o mry.png  https://raw.githubusercontent.com/MrYsLab/s2-pi/master/docs/images/mry.png",
            "title": "Download An Icon File"
        },
        {
            "location": "/#installing-the-extension-from-the-extension-library",
            "text": "After starting s2pi, when the Scratch editor appears, go to the More Blocks section of the\neditor.    Click on the Add an Extension button and the Extension Library page will appear.    Double click the MisterYsLab icon, and the extension blocks should appear.",
            "title": "Installing The Extension From The Extension Library"
        },
        {
            "location": "/#removing-a-scratch-extension",
            "text": "When developing an extension, you will probably need to reload it multiple times as you add features\nand get the bugs out. To remove an extension, click on the arrow next to the extension name and select Remove extension blocks .  You are now ready to make your changes and to reload the extension.",
            "title": "Removing A Scratch Extension"
        },
        {
            "location": "/#using-the-s2-pi-blocks",
            "text": "Now that the JavaScript extension has been loaded and the server is running, you can try using\nthe extension blocks within the Scratch editor.  As each custom Scratch block is executed, the terminal window will display the message sent from\nthe extension to the server. If a pin is set to be a digital input, and the pin\nchanges state, the changes for that pin\nwill also be displayed in the console with the pigpio callback information.    The NOT SANDBOXED message is coming from Scratch because we started Scratch from\ninside a terminal window. This message can be safely ignored.",
            "title": "Using The s2-pi Blocks"
        },
        {
            "location": "/#opening-a-communication-channel-between-the-extension-and-the-server",
            "text": "Scratch does not provide a mechanism to\nautomatically connect a communication channel between the extension and the server.\nTherefore, the  Connect to s2-pi server block \nmust be executed before using any of the other blocks.  If you forget to do this, an alert will appear on the screen. In addition, the connection indicator\nwill be yellow.    When the connection is complete the indicator will go from yellow to green.",
            "title": "Opening A Communication Channel Between The Extension And The Server"
        },
        {
            "location": "/#changing-the-state-of-a-digital-output-pin",
            "text": "If you have a device, such as an LED connected to a GPIO pin, you can set its state to a \"1\" or \"0\"\nby using the  Set BCM Output block .",
            "title": "Changing The State Of A Digital Output Pin"
        },
        {
            "location": "/#changing-the-state-of-a-digital-output-pin-using-pwm",
            "text": "Using the same LED device, you can set its brightness (from 0 to 255) using the  Set BCM PWM Output  block.",
            "title": "Changing The State Of A Digital Output Pin Using PWM"
        },
        {
            "location": "/#getting-input-from-a-digital-input-pin",
            "text": "If you have a device, such as a switch, connected to a GPIO pin, you can read the switch's current\nstate. First, you must set the pin as an input using the  Set BCM as Input  block. This sets up pigpio\nto provide notification of a state change on the pin. Now to see the current state, use the Read Digital\nPin reporter block.",
            "title": "Getting Input From A Digital Input Pin"
        },
        {
            "location": "/#controlling-a-servo-motor",
            "text": "If you connect a servo motor to a GPIO pin, you can control its movement between 0 and 180 degrees by using the Set BCM As Servo  block.",
            "title": "Controlling A Servo Motor"
        },
        {
            "location": "/#playing-a-tone",
            "text": "If you connect a Piezo buzzer to a GPIO pin, you can play a short tone by using the  Tone  block.",
            "title": "Playing A Tone"
        },
        {
            "location": "/#creating-a-javascript-extension-file",
            "text": "The format for the JavaScript extension file has been defined by the Scratch team and\nyou can view the specification  on this web page .  The JavaScript extension file is comprised of boiler plate code,\nblock descriptor code that creates the Scratch blocks in the Scratch editor,\nand the code that you write that acts as a callback for the blocks created in the descriptor section.  This was mentioned previously, but we will take this opportunity to mention it again. As you write\nyour JavaScript extension code\nand install it into the Scratch editor, the installation may result in no blocks being displayed.\nIf you introduce any errors in the file, Scratch silently fails, leaving you to debug your\nfile without any help from Scratch. Therefore it is a good idea to work on things incrementally.",
            "title": "Creating a JavaScript Extension File"
        },
        {
            "location": "/#basic-boiler-plate",
            "text": "I would suggest, first starting with the basic boiler plate provided in the specification.  (function(ext) {\n    // Cleanup function when the extension is unloaded\n    ext._shutdown = function() {};\n\n    // Status reporting code\n    // Use this to report missing hardware, plugin or unsupported browser\n    ext._getStatus = function() {\n        return {status: 2, msg: 'Ready'};\n    };\n\n    // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n        ]\n    };\n\n    // Register the extension\n    ScratchExtensions.register('Sample extension', descriptor, ext);\n})({});  Just copy this code into your favorite editor, and save the file with a .js extension.\nThen load the file into Scratch. You should then see something like this in the Scratch Editor.\nRemember to select More Blocks or you will not see the custom blocks. In this case, we have\nnot yet defined any blocks, and that is why no blocks appear.    Now let's modify the boiler plate slightly to change the indicator from the default green to yellow.\nAlso, we will change the title of the extension from \"Sample Extension\" to \"My Extension\".  (function(ext) {\n    // Cleanup function when the extension is unloaded\n    ext._shutdown = function() {};\n\n    // Status reporting code\n    // Use this to report missing hardware, plugin or unsupported browser\n    ext._getStatus = function() {\n        return {status: 1, msg: 'Ready'};\n    };\n\n    // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n        ]\n    };\n\n    // Register the extension\n    ScratchExtensions.register('My extension', descriptor, ext);\n})({});  To change the color of the indicator,   status  was set from a value of 2 to 1,\nand to change the extension name, the line near the bottom of the file was modified.",
            "title": "Basic Boiler Plate"
        },
        {
            "location": "/#block-descriptor-section",
            "text": "The specifications for creating different types of blocks, including adding drop down menus\nand parameter fields within the blocks is nicely documented on\nthe  Scratch page ,\nso we won't cover that information in detail here. Let's just take a quick look at the\nblocks descriptors that s2-pi uses.      // Block and block menu descriptions\n    var descriptor = {\n        blocks: [\n            // Block type, block name, function name\n            [\"w\", 'Connect to s2_pi server.', 'cnct'],\n            [\" \", 'Set BCM %n as an Input', 'input','PIN'],\n            [\" \", \"Set BCM %n Output to %m.high_low\", \"digital_write\", \"PIN\", \"0\"],\n            [\" \", \"Set BCM PWM Out %n to %n\", \"analog_write\", \"PIN\", \"VAL\"],\n            [\" \", \"Set BCM %n as Servo with angle = %n (0\u00b0 - 180\u00b0)\", \"servo\", \"PIN\", \"0\"],     // ***Hackeduca --> Block for Servo\n            [\" \", \"Tone: BCM %n HZ: %n\", \"play_tone\", \"PIN\", 1000],\n            [\"r\", \"Read Digital Pin %n\", \"digital_read\", \"PIN\"]\n\n        ],\n        \"menus\": {\n            \"high_low\": [\"0\", \"1\"]\n\n        },\n        url: 'http://MrYsLab.github.io/s2-pi'\n    };  A block descriptor consists of several fields.   The first field describes the shape of the block.\nCommand blocks are created by setting the first fields to \" \".  A reporter block is created by setting\nthis field to \"r\".  The second field is the text that\nappears in the block. Within that text, you might include a drop down menu, shown by using %m. The\nmenu contents are defined within the  menu  section of the block descriptor.\nYou can also have the block provide blanks for the\nuser to input parameters for the block. %n indicates that this parameter will be a number.  The third field is the name of the function that will be called when the block executes.\nYou will need to provide the contents of that function within the extension file.  The remaining fields provide default values for the parameters defined, if any, in the second\ndescriptor field.",
            "title": "Block Descriptor Section"
        },
        {
            "location": "/#block-handlers",
            "text": "Once you have your blocks created and are able to successfully load them into Scratch,\nit is time to create the code for the block handlers.",
            "title": "Block Handlers"
        },
        {
            "location": "/#a-really-simple-example",
            "text": "Now let's create a really simple extension file that will do all of the processing within\nthe JavaScript file (no server is needed). When this extension is loaded, the indicator is set\nto yellow. When the  Start The Program  block is executed, it will turn the indicator from\nyellow to green.  (function(ext) {\n\n   var myStatus = 1 ; // initially set status to yellow\n   // Cleanup function when the extension is unloaded\n\n   ext._shutdown = function() {};\n\n   // Status reporting code\n\n   // Use this to report missing hardware, plugin\n\n   // or unsupported browser\n\n   ext._getStatus = function() {\n     return {status: myStatus, msg: 'Ready'};\n   };\n\n   // added function to support the Start The Program block\n   ext.goGreen = function() {\n     myStatus = 2;\n   };\n\n   // Block and block menu descriptions\n   var descriptor = {\n     blocks: [\n       [\" \", \"Start The Program\", \"goGreen\"]\n     ]\n   };\n\n   // Register the extension\n   ScratchExtensions.register('My extension', descriptor, ext);\n })({});  In this extension, We add a variable,  myStatus  and initialize it with a value of\n\"1\".  The _getStatus method, a method that Scratch calls periodically to set the indicator, has\nbeen modified. We changed the hard coded value for status to be the myStatus variable. Because\nmyStatus is set to \"1\" the indicator is initially yellow.  We defined a  Start The Program  block and in the descriptor indicated that this block will\nbe handled by the  goGreen  function.  The goGreen function, called when the block is used in a Scratch script, sets myStatus to \"2\", which\n will turn the indicator to green.  As you can see, it is possible to perform all of the processing in the JavaScript extension. In fact,\nthe default extension provided with Scratch for the Raspberry Pi, \"Pi GPIO\", does just that. It\ncontrols the GPIO pins by making some low-level GPIO calls.  However, if you wish to start connecting more complicated devices, such as i2c devices,\nprogramming may get to be difficult, if not impossible, because of the limitations imposed by\nScratch on the extension file.  For example, getting the \"Pi GPIO\" extension to play a tone would be, to say the least, a challenge.  To get around the restrictions imposed by the Scratch editor, we can add a server\nfor flexibility and ease of programming.",
            "title": "A Really Simple Example"
        },
        {
            "location": "/#providing-a-communication-channel-between-scratch-and-the-server",
            "text": "As mentioned before, you can do all processing within the extension if you wish,\nbut personally, I prefer to\n\"outsource the rough stuff\" to another process. For s2-pi, that process is s2_pi.py.  The one complication is that we need a way for the Extension and server process to be able to\ncommunicate with one another, asynchronously and bi-directionally. Whenever a command extension\nblock is executed, it needs to be able to send the command, in addition to any parameters that may\nbe associated with that command, to the server process.  And in the other direction, from the server to the extension, the server needs to be able to notify\nthe extension whenever a reporting event occurs.  The communication should be asynchronous in that neither the extension nor the server should need\nto poll for incoming messages. This makes the system a lot more efficient and easier to program.\nNot having\nthe need for complicated concurrency schemes is a plus. When a message arrives, it essentially\ngenerates an event that triggers the processing of that message. When no messages are available,\nthe program is essentially dormant.",
            "title": "Providing A Communication Channel Between Scratch And The Server"
        },
        {
            "location": "/#some-websocket-background",
            "text": "WebSockets satisfy all of our communication needs rather nicely, and since it is already\nbuilt into Scratch, extension implementation is greatly\nsimplified. Unfortunately, none of this is documented by the Scratch team. Don't worry,\n we will show you how to use WebSockets in the extension. For the server, we just need to create a\n class that implements the server inherited from\na WebSocket library base class. Again, you will be shown how to manage WebSockets on the server side as well.\nAll in all, it is a pretty elegant and simple solution for our communication needs.  A WebSocket is  defined by Wikipedia  as a\n\"a computer communications protocol, providing full-duplex communication channels\nover a single TCP connection\". WebSockets by their nature are event driven, and therefore are a perfect\nfit for our needs.  Similar to an IP socket, one side of the connection acts as the client that initiates the socket,\nand the other\nside is the server that accepts connection requests and completes the connection.  For s2-pi the extension is the client, and the server is, you guessed it, the server.  The WebSocket API requires some methods to be implemented to support the WebSocket event\ndriven protocol.  Let's take a look at how s2-pi establishes a WebSocket, and the code it uses to do so.",
            "title": "Some WebSocket Background"
        },
        {
            "location": "/#establishing-the-connection",
            "text": "In order to establish a connection, we first need a WebSocket server to be running and ready\nto accept connection requests. The s2_pi.py server, S2PI,  inherits from the WebSocket class.\nS2PI needs to overwrite and implement 3 methods inherited from the base class:   handleConnected  handleMessage  handleClose   Similarly, on the client, JavaScript extension side, we need to implement a similar set of functions.   window.socket.onopen  window.socket.onmessage  window.socket.onclose   In  s2_pi.py ,\nthe function near the bottom of the file,  run_server , in addition to starting\nup Scratch, instantiates the WebSocket providing the IP address and port\nnumber we wish to use. We also need to pass a reference to our implementation\nclass (S2PI) so that the overwritten methods within S2PI will be called\nwhen a WebSocket event occurs.\nThe last line of the method assures that the WebSocket server will run \"forever\".  def run_server():\n    os.system('scratch2&')\n    server = SimpleWebSocketServer('', 9000, S2Pi)\n    server.serveforever()  The run_server method is called when we start s2_pi.py:  if __name__ == \"__main__\":\n    try:\n        run_server()\n    except KeyboardInterrupt:\n        sys.exit(0)  Once  run_server  is called, S2PI is waiting for a connection request.  Now it's the extension's turn to initiate the connection request.\nIn order for the server to receive a connection request, the Connect to s2_pi server  block must be executed within a Scratch script.\nActivating this block calls the  cnct  function within our JavaScript extension.\n`\nThe  cnct  function instantiates a WebSocket using the same IP address and port number used by the server.\nThe instantiation issues a connection request.  ext.cnct = function () {\n        window.socket = new WebSocket(\"ws://127.0.0.1:9000\");  When the server receives this connection request, a handshake between both sides ensues, and\nif the connection is successful,  handleConnected  is called.  On the extension end, a successful connection results in  window.socket.onopen  being\ncalled.  Both sides are now ready to send and receive messages.",
            "title": "Establishing The Connection"
        },
        {
            "location": "/#formatting-messages-to-go-across-the-network",
            "text": "By convention, our application will use a hash/dictionary data structure to construct\nour messages. A hash (JavaScript) and dictionary(Python) are roughly equivalent data structures,\nthat allow the easy extraction of data using name/value pairs.  Luckily, the syntax for both JavaScript and Python are the same.  Here is a list of messages constructed and sent by the Scratch extension to notify the\nserver that a command block has been executed:  Block:                    Connect To s2-pi Server\nMessage:                  {'command': 'ready''}\n\nBlock:                    Set BCM Pin As An Input\nMessage:                  {'command': 'input', 'pin': pin}\n\nBlock:                    Set BCM Output To\nMessage:                  {'command': 'digital_write', 'pin': pin, 'state': state}\n\nBlock:                    Set BCM PWM Output\nMessage:                  {'command': 'analog_write', 'pin': pin, 'value': value}\n\nBlock:                    Set BCM as Servo\nMessage:                  {'command': 'servo', 'pin': pin, 'value': value}\n\nBlock:                    Tone\nMessage:                  {'command': 'tone', 'pin': pin, 'frequency': frequency}  Notice that each of these messages has a  command  field to identify the type of message.\nWhen the server receives a message, it simply dereferences the command field to determine the action\nto take.  On both sides of the interface, we convert the hash/dictionary message structures into strings\nusing JSON, so that message can be carried over the network. When a message is received,\nwe need to reconstruct the string back to the native data structure so that we can easily access\nall the fields of the message.  To convert from a hash to a string on the extension side, the JSON.stringify method is used.  var msg = JSON.stringify({\n                \"command\": \"ready\"\n            });\n            window.socket.send(msg);  The converted message is then sent over the socket using the  send  function.  When the message is received on the server side, it needs to be converted from the string representation\nback to the native data structure.  The  handleMessage  method in s2_pi.py performs this conversion.  payload = json.loads(self.data)  Here the string, represented as self.data, is converted back to the data structure by the call to\njson.loads. The converted string is assigned to the payload variable and can now be manipulated as\na standard Python dictionary.  You've probably noticed that all the WebSocket action of interest is handled by window.socket.onmessage  on the JavaScript side, receiving any messages that the server sends,\nsuch as reporter data, and  handleMessage  on the Python side, receiving all the command\nrequests from the extension.",
            "title": "Formatting Messages To Go Across The Network"
        },
        {
            "location": "/#reporter-blocks",
            "text": "For S2PI, the only reporter block is  Read Digital Pin . Before using this block in a Scratch\nscript,\nthe  Set BCM as an Input  block must first be used.  The following is the implementation function in the extension for this block:  ext.input = function (pin) {\n        if (connected == false) {\n            alert(\"Server Not Connected\");\n        }\n        // validate the pin number for the mode\n        if (validatePin(pin)) {\n            var msg = JSON.stringify({\n                \"command\": 'input', 'pin': pin\n            });\n            window.socket.send(msg);\n        }\n    };  We first make sure that a connection was established, and if not an alert is generated in the\nScratch editor. Next, we make sure that the pin specified is valid. The check to do this simply checks\nthe pin is in the range of 0-31. Finally, we create and send a message with a command of \"input\"\nsupplying\nthe pin number that the user entered in the block.  When the server receives this message, the selected GPIO pin is set to be an input pin.      def handleMessage(self):\n        # get command from Scratch2\n        payload = json.loads(self.data)\n        print(payload)\n        client_cmd = payload['command']\n        # When the user wishes to set a pin as a digital Input\n        if client_cmd == 'input':\n            pin = int(payload['pin'])\n            self.pi.set_glitch_filter(pin, 20000)\n            self.pi.set_mode(pin, pigpio.INPUT)\n            self.pi.callback(pin, pigpio.EITHER_EDGE, self.input_callback)  Here is the beginning of the server's  handleMessage  method. The first thing that happens is\nwhen a message is received, is that the message is converted back to a dictionary.  The message just received was an  input  command message. The pin number is extracted from the\nmessage, converted from its string representation to an integer, and then 3 pigpio calls are made.  The first sets a \"glitch\" value. If using a push button switch, this will debounce \n the switch.  Then the pin is set to be an input pin, and finally, we associate a callback method for pigpio to\ncall whenever there is a state change detected on the pin.  When a call back occurs, a message is constructed and sent to the extension notifying it of the\nstate change.      def input_callback(self, pin, level, tick):\n        payload = {'report': 'digital_input_change', 'pin': str(pin), 'level': str(level)}\n        print('callback', payload)\n        msg = json.dumps(payload)\n        self.sendMessage(msg)  The  json,dumps  call translates the dictionary into a string.  The message is then sent with the sendMessage call.  The extension receives this message in its  onmessage  function.  window.socket.onmessage = function (message) {\n            var msg = JSON.parse(message.data);\n\n            // handle the only reporter message from the server\n            // for changes in digital input state\n            var reporter = msg['report'];\n            if(reporter === 'digital_input_change') {\n                pin = msg['pin'];\n                digital_inputs[parseInt(pin)] = msg['level']\n            }\n            console.log(message.data)\n        };  Here the message is converted back to a hash by the call to JSON.parse. The report type is checked\nand the digital_inputs array is modified to reflect the state change.\nThe pin value is converted from its string representation to an integer and is used as an index to\nstore the state change information in the  digital_inputs  array.  When the  Read Digital Input  reporter block is encountered in a Scratch script,\nits associated function is called. The current state of the pin associated with this block\nis retrieved\nby indexing into the  digital_inputs  array.  [\"r\", \"Read Digital Pin %n\", \"digital_read\", \"PIN\"]\n\next.digital_read = function (pin) {\n        if (connected == false) {\n            alert(\"Server Not Connected\");\n        }\n        else {\n                return digital_inputs[parseInt(pin)]\n\n        }\n    };",
            "title": "Reporter Blocks"
        },
        {
            "location": "/#saving-your-project",
            "text": "After creating your project you can save it by selecting  File/Save Project  in the Scratch\neditor menu.    This will save your file with a .sbx extension.  The current version of the Scratch 2 editor contains a bug. If you go to save a project\nwhen using a custom extension (for some reason this bug does not occur if you use one of\nthe two \"standard\" extensions supplied with the editor), the file is saved with a .sbx\nextension. When you go to load a previously saved project, .sbx files do not appear in the\nproject choice menu. To get around this, .sbx projects need to be renamed using a .sb2\nextension.  The s2-pi distribution supplies a utility that will rename all .sbx files to .sb2 files for\na given directory.  To use this utility, open a terminal window and CD into the directory that contains\nthe .sbx project files.  Next type the following to properly rename the files:  sbx_to_sb2  If you modify a project that was loaded with the .sb2 extension and then save it, the file\nwill be renamed with the .sbx extension.  Hopefully, this rather annoying bug will be fixed in the near future.",
            "title": "Saving Your Project"
        },
        {
            "location": "/#reloading-a-saved-project",
            "text": "When you select File/ Load Project, only .sb2 files are shown in the file chooser dialog.\nTherefore if you saved a project and did not convert its file type, refer to the previous\nsection  Saving Your Project , to learn how to convert the file to the correct type.  After fixing the file extension type, if you then select  File/Load Project , the .sb2 files be available\n for selection in the file chooser dialog.",
            "title": "Reloading A Saved Project"
        },
        {
            "location": "/#red-blocks",
            "text": "If you installed the extension  using method 1 , then\nwhen you load a previously saved project, you will see the extension blocks come up as red blocks :    To solve this problem, just reload the extensions blocks as described\nin the  Installing The s2-pi JavaScript Extension File Into The Scratch Editor  section of\nthis document.  After doing so, the extension blocks should be restored.",
            "title": "Red Blocks"
        },
        {
            "location": "/#go-forth-and-code",
            "text": "We have explored:   Creating a JavaScript Extension File  Creating a Python server derived from the WebSocket class  Constructing and sending messages, both in the extension and the server.  Receiving, deconstructing and processing the message for both the extension and server.   With that in hand, you should have a good idea of how to code both the JavaScript extension and\nthe associated server side code.  If you have any comments, questions or suggestions, please let me know at:  MisterYsLab@gmail.com",
            "title": "Go Forth And Code!"
        },
        {
            "location": "/#contributors",
            "text": "The servo control code was developed and supplied by  Edson Sidnei Sobreira",
            "title": "Contributors"
        }
    ]
}